<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Working with Networks · FeedbackNets Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FeedbackNets Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li><a class="toctext" href="../chains_vs_trees/">Chains vs Trees</a></li><li class="current"><a class="toctext" href>Working with Networks</a><ul class="internal"><li><a class="toctext" href="#Slicing-1">Slicing</a></li><li><a class="toctext" href="#Validating-names-1">Validating names</a></li><li><a class="toctext" href="#Moving-to-GPU-1">Moving to GPU</a></li><li><a class="toctext" href="#Reset-1">Reset</a></li></ul></li></ul></li><li><a class="toctext" href="../../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Guide</li><li><a href>Working with Networks</a></li></ul><a class="edit-page" href="https://github.com/cJarvers/FeedbackNets.jl/blob/master/docs/src/guide/working_with_networks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Working with Networks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Working-with-networks-1" href="#Working-with-networks-1">Working with networks</a></h1><p>There are several points to keep in mind while working with feedback networks.</p><h2><a class="nav-anchor" id="Slicing-1" href="#Slicing-1">Slicing</a></h2><p>Both <code>FeedbackChain</code>s and <code>FeedbackTree</code>s support slicing like a normal Flux <code>Chain</code> in order to select a subset of operations in the network.</p><pre><code class="language-julia-repl">julia&gt; net = FeedbackChain(
           Merger(&quot;s1&quot;, Dense(5,10), +),
           Dense(10,5),
           Splitter(&quot;s1&quot;),
           Dense(5,1)
       )
FeedbackChain(Merger(&quot;s1&quot;, Dense(5, 10), +), Dense(10, 5), Splitter(&quot;s1&quot;), Dense(5, 1))

julia&gt; net[1]
Merger(&quot;s1&quot;, Dense(5, 10), +)

julia&gt; net[1:2]
FeedbackChain(Merger(&quot;s1&quot;, Dense(5, 10), +), Dense(10, 5))</code></pre><p>This is convenient to trace the information flow through the network by applying a subset of layers at a time. However, by doing this you run the risk of selecting some <code>Merger</code>s that get input from <code>Splitter</code>s which are not in your selected slice. Accordingly, the states required to calculate the next timestep are not added to the dictionary any more. Slicing should therefore be used with care.</p><h2><a class="nav-anchor" id="Validating-names-1" href="#Validating-names-1">Validating names</a></h2><p>In order to test whether all inputs required by <code>Merger</code>s in a network are actually provided by corresponding <code>Splitter</code>s, you can use the function <code>namesvalid</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FeedbackNets.AbstractFeedbackNets.namesvalid-Tuple{AbstractFeedbackNet}" href="#FeedbackNets.AbstractFeedbackNets.namesvalid-Tuple{AbstractFeedbackNet}"><code>FeedbackNets.AbstractFeedbackNets.namesvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">namesvalid(net::AbstractFeedbackNet)</code></pre><p>Check if the input names of all <code>Mergers</code> in <code>net</code> have a corresponding <code>Splitter</code> and that no two <code>Splitter</code>s have the same name.</p></div></div><a class="source-link" target="_blank" href="https://github.com/cJarvers/FeedbackNets.jl/blob/b321c7d97a4ec56f65c5fa70cf56cd65cde84223/src/AbstractFeedbackNets.jl#L35-L40">source</a></section><p>If each <code>Splitter</code> has a unique name and each <code>Merger</code> name corresponds to a <code>Splitter</code>, validation will succeed.</p><pre><code class="language-julia">namesvalid(FeedbackChain(
    Merger(&quot;s1&quot;, Dense(5,10), +),
    Dense(10, 5),
    Splitter(&quot;s1&quot;)
))</code></pre><pre><code class="language-none">true</code></pre><p>However, if one of these constraints is violated, validation fails.</p><pre><code class="language-julia">namesvalid(FeedbackChain(
    Merger(&quot;s1&quot;, Dense(5,10), +),
    Dense(10, 5),
    Splitter(&quot;s2&quot;)
))</code></pre><pre><code class="language-none">false</code></pre><h2><a class="nav-anchor" id="Moving-to-GPU-1" href="#Moving-to-GPU-1">Moving to GPU</a></h2><p>In order to perform computations on a GPU, the usual Flux syntax can be used to move the model:</p><pre><code class="language-julia">julia&gt; net = net |&gt; gpu</code></pre><p>However, this does not work natively for dictionaries and accordingly also not for feedback networks wrapped in a <code>Flux.Recur</code> where the state is encoded as a dictionary. In order to move a dictionary to the GPU, generate a new <code>Dict</code> with the same keys and values moved to GPU:</p><pre><code class="language-julia">julia&gt; state = Dict(key =&gt; gpu(val) for (key, val) in pairs(state))</code></pre><h2><a class="nav-anchor" id="Reset-1" href="#Reset-1">Reset</a></h2><p>A <code>Flux.Recur</code> will keep accumulating gradients via its internal state, also across sequences. In order to prevent this and start from a fresh state for each new sample, you should call <code>Flux.reset!()</code> on your model after each input sequence. Typically, you would do this whenever you calculate the loss or accuracy. See <a href="https://fluxml.ai/Flux.jl/stable/models/recurrence/#Truncating-Gradients-1">here</a> for details.</p><footer><hr/><a class="previous" href="../chains_vs_trees/"><span class="direction">Previous</span><span class="title">Chains vs Trees</span></a><a class="next" href="../../reference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
